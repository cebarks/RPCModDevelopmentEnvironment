apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'application'

mainClassName = mainClass
compileJava.options.encoding = 'UTF-8'
sourceCompatibility = 1.8
version = '1.0'

buildscript {
	repositories {
		mavenCentral()
	}

	dependencies {
		classpath 'org.tmatesoft.svnkit:svnkit:1.8.7'
		classpath 'net.dongliu:jvcdiff:1.2.3'
	}
}

import org.tmatesoft.svn.core.wc.*
import org.tmatesoft.svn.core.*
import net.dongliu.vcdiff.VcdiffDecoder

import java.nio.file.CopyOption
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption;


repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.11'
    compile fileTree(dir: 'lib/jars', include: '*.jar')
}

sourceSets {
    main {
        java {
            srcDir rpcSrcDir
        }
    }
}

jar {
    manifest {
        attributes(
            "Manifest-Version"  : "1.0",
            "Main-Class"        : mainClass,
            "Class-Path"        : fileTree(dir:'lib/jars',include:'*.jar').collect { "lib/jars/$it.name" }.join(" ")
        )
    }

    doLast {
        copy {
            from fileTree(dir: './', include: ['lib/', 'res/', 'maps/'])
            into 'build/libs'
        }
    }
}

task decompile(type: JavaExec) {
    doFirst {
        copy {
            from file("$installDirectory/Core.jar")
            into 'tmp/'
        }

        file("tmp/decomp-classes").mkdirs()
    }

	inputs.file file('tmp/Core.jar')
	//outputs.file fileTree(dir: rpcSrcDir, include: '**/*.java')
    main = "-jar"
    args relativePath("java-decompiler.jar")
    args "-dgs=1 -den=1 -lac=1 -nls=1 -rsy=1 -ind=    "
    args relativePath("tmp/Core.jar")
    args relativePath("tmp/decomp-classes")

    doLast {
        copy {
            from zipTree("tmp/decomp-classes/Core.jar")
            into rpcSrcDir
        }

        delete "$rpcSrcDir/META-INF", fileTree(dir: rpcSrcDir, include: "*.jar"), "$rpcSrcDir/org/eclipse"
    }
}

task setupProject {
	inputs.file fileTree(dir: "$installDirectory/", include: ['maps/', 'lib/', 'res/'])
	outputs.file fileTree(dir: "./", include: ['maps/', 'lib/', 'res/'])

	doLast {
		copy {
			from fileTree(dir: "$installDirectory/", include: ['maps/', 'lib/', 'res/'])
			into './'
		}

		println "Finished setting up project"
	}
}

task cleanResources {
	inputs.file fileTree(dir: './', include: ['lib/', 'logs/', 'maps/', 'profiles/', 'res/', 'tmp/', rpcSrcDir])
	outputs.file fileTree(dir: './', include: ['lib/', 'logs/', 'maps/', 'profiles/', 'res/', 'tmp/', rpcSrcDir])
	doLast {
		delete 'lib/', 'logs/', 'maps/', 'profiles/', 'res/', 'tmp/', rpcSrcDir, 'patch'
	}
}

task fullClean(dependsOn: ['clean', 'cleanResources', 'cleanIdea', 'cleanIdeaWorkspace'])

idea {
	project {
		languageLevel = '1.7'
	}
	
	module {
		sourceDirs += file("$rpcSrcDir")
	}
}

task getRPCPatch << {
	def game = file("$rpcSrcDir/rpc/launcher/Game.java")
	def version = null
	game.eachLine { line ->
		line = line.trim()
		if(line.matches('private static final String gameVersion = ".*";')) {
			def split = line.split('"')
			version = split[1].replaceAll(' ', '')
		}
	}

	if(version == null) {
		println 'unable to locate game version from source'
	}
	else {
		//check if the patch has already been downloaded else grab it
		def patch = file('patch')
		if(!patch.exists() || (patch.isDirectory() && patch.listFiles().length == 0)) {
			def clientManager = SVNClientManager.newInstance()
			SVNUpdateClient update = clientManager.getUpdateClient()

			try {
				SVNURL url = SVNURL.parseURIEncoded("https://github.com/Emeegeemee/RPCPatches/trunk/patches/$version/")
				update.doCheckout(url, patch, SVNRevision.HEAD, SVNRevision.HEAD, SVNDepth.INFINITY, true)

				delete 'patch/.svn/'
			}
			catch (SVNException e) {
				def errorCode = e.getErrorMessage().getErrorCode()
				if (SVNErrorCode.UNSUPPORTED_FEATURE.equals(errorCode)) {
					println 'Patch points to a file not a directory'
				} else if (SVNErrorCode.RA_ILLEGAL_URL.equals(errorCode)) {
					println "The requested patch doesn't exist"
				} else {
					println 'unknown svn exception'
					e.printStackTrace();
				}

				return
			}
		}

		def closure
		closure = { path ->
			def patchFolder = file("patch$path")

			patchFolder.eachDir {closure("$path/$it.name")}

			patchFolder.eachFile(groovy.io.FileType.FILES, {
				def patchFile = file("patch$path/${it.name}")
				def name = it.name.replaceAll('\\.patch', "")
				def targetFile = file("$rpcSrcDir$path/$name")

				if(it.name.endsWith(".patch")) {
					if (targetFile.exists()) {
						def sourceFile = file("tmp/$it.name")

						Files.copy(Paths.get(targetFile.toURI()), Paths.get(sourceFile.toURI()))
						VcdiffDecoder.decode(sourceFile, patchFile, targetFile)
						delete "tmp/$it.name"
					}
				}
				else {
					file("$rpcSrcDir$path/").mkdirs()
					Files.copy(Paths.get(patchFile.toURI()), Paths.get(targetFile.toURI()), StandardCopyOption.REPLACE_EXISTING)
				}
			})
		}
		closure('')
	}
}

getRPCPatch.dependsOn decompile
setupProject.dependsOn getRPCPatch